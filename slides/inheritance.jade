section
  section
    h1 Inheritance

  section
    h2 Inheritance
    ul
      li Let's take this one step further:
      li <code>Car.prototype</code> can be an arbitrary object
      li i.e. we can use an instance produced by another constructor 

        pre: code.
          function Vehicle(wheels) {
            this.wheels = wheels;
          }

          // redefine Car.prototype
          Car.prototype = new Vehicle(4);
          Car.prototype.drive = function() {...}

          var ferrari = new Car("Ferrari");
          var ford    = new Car("Ford");

          ferarri.wheels; // -> 4

  section
    h2 The Prototype, Part IV
    ul
      li What if we add something to the <code>Vehicle</code> prototype?

        pre: code.
          Vehicle.prototype.getAxes = function() {
            // assume 2 wheels per axis
            return this.wheels / 2;
          }

          show(ferrari);

      li.fragment Result?

        pre: code.
          name=Ferrari
          wheels=4
          drive=function () {...}
          getAxes=function () {...}

      li.fragment The new function automatically appears to be a member
        |of our <code>Car</code> instance
      li.fragment We didn't even have to call the constructor again

  section
    :markdown
      ## What we've learned
      * All objects that share the same *prototype* share all
        the properties defined on that prototype
      * 

  section
    h2 The Prototype, Part II
    ul
      li Let's go back to our
        a(href='#/2/4') previous question

        pre: code.
          function show(obj) {
            for (var key in obj) {
              console.log(key + "=" + obj[key]);
            }
          }

          show(ferrari);

      li Result:

        pre: code.
          name=Ferrari
          drive=function () {
            console.log(this.name + " goes vroom!");
          }


  section
    :markdown
      ## What have we learned?
      * `for in` iterates over *all* properties, 
        including those defined on the *prototype*
      * In fact, looking up a property of an object traverses the
        *entire* "prototype-chain" until either a match is 
        found or the end of the chain is reached <br/>
        (i.e. `prototype == undefined`)
      * This is the *essence* of JavaScript's object model

  section
    :markdown
      ## Inheritance
      * JavaScript's object model is *prototype*-based
      * Significantly different from the "classic" OO model (C++, Java, Ruby, etc.)
      * Most important difference: **there are no classes**

  section
    :markdown
      # WAT?

  section
    :markdown
      ## No classes, are you serious?
      * JavaScript has no concept of classes built into the language
      * Instead, all we have are *instances* of objects
      * New objects can be created by *copying* existing objects
      * These objects remember which object they were copied from, and
        inherit certain features

  section
    :markdown
      ## The Prototype
      * JavaScript's object model is *prototype*-based
      * Every object has a special property called `prototype`
      * An object's *prototype* is just another object
      * That object in turn has a prototype, creating what's known as a *prototype chain*
      * If no protype is set explicity, it will be `Object`

  section
    :markdown
      ## Rolling our own classes
      * BUT - it's fairly easy to implement one *on top*
    pre: code.
        // Simple class model, no inheritance
        function Class(constructor, properties) {
          if (typeof constructor === "object") {
            return Class(function() {}, constructor)
          } else {
            // constructor
            function klass() {
              constructor.apply(this, arguments);
            }

            // prototype - more on this later
            klass.prototype = properties;
            klass.prototype.constructor = constructor;

            return klass;
          }
        }

  section
    :markdown
      ## Rolling our own classes
      Let's use it!
    pre: code.
        var Car = new Class(
          function(name) {
            this.name = name;
          }, {
            drive: function() {
              console.log(this.name + " goes: vrooom!");
            }
          });

        var ferrari = new Car("Ferrari");
        ferrari.drive();  
        // Output: "Ferrari goes: vrooom!"

  section
    :markdown
      ## Still missing some stuff:
      * Inheritance
      * Static methods
      * Private instance variables
      * But it works...

