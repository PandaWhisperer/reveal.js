section
  section
    :markdown
      # Organizing Your Code

  section
    :markdown
      ## The Module Pattern

      * Biggest challenges to modular code:
        - Global variables shared accross files
        - Encapsulation (keeping your privates private)
      * Common approach: the module pattern
        - widely used (jQuery plugins, Twitter Bootstrap, etc.)
        - flexible
        - simple

  section
    h2 The Basic Pattern
    ul
      li Wrap entire code into an <em>anonymous, self-executing</em> function

        pre: code.javascript.
          (function() {
            // code here
          })();

      li Closure provides a "safe" place for internal variables etc.
      li We can make dependencies explicit by adding them as parameters

        pre: code.javascript.
          (function($) {
            // '$' inside the closure references jQuery
          })(jQuery);

    aside.notes
      Here's an interesting fact about JavaScript:
      the <em>only</em> thing that creates scope is a function.

  section
    h2 Exporting functionality
    ul
      li What if the point of our code is to provide
        |functionality to other parts of the code?
      li We need a way to export objects/functions

        pre: code.javascript.
          var Module = (function() {
            var module = {};

            // internals stay private
            var foo = something();
            function internalHelper() { ... }

            // exportable functions defined on the module
            module.method1 = function() {
              // ...
            }
            module.method2 = function() {
              // ...
            }

            return module;
          })();

  section
    h2 Augmentation / Submodules
    ul
      li Sometimes our modules may become more complicated
      li So we want to spread them over several files
      li Solution: pass existing module into closure

        pre: code.javascript.
          var Module = (function(module) {
            // we can add new methods...
            module.method3 = function() { ... }

            // ...or an entire submodule
            module.submodule = {
              method1: function() { ... },
              method2: function() { ... }
            }

            return module;
          })(Module);

      li.fragment Better: loose coupling

        pre: code.javascript.
          var Module = (function(module) {
            // ...
          })(Module || {}); // parts can be loaded in any order
