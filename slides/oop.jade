section
  section
    h2 Object Orientation
    ul
      li What we've learned so far:
        :markdown
          - Objects are hashmaps, mapping keys to values
          - Properties can be acessed using either `[]` or dot-notation
          - We can construct objects using literal notation (JSON)
          - Functions are values, just like primitive types
      li Next step: let's make some "real" objects!

  section
    h2 Object Orientation, Part II
    ul
      li Since functions are values, we can assign them to properties

        pre: code.
          var car = {
            name: "Ferrari",
            drive: function() {
              console.log(this.name + " goes vroom!");
            }
          }

          car.drive();   // -> "Ferrari goes vroom!"

       li.fragment And that's how you do OOP in JavaScript!

  section
    h2 Object Orientation, Part III
    ul
      li Obviously, this is kind of limited
      li All we can do is construct literal objects
      li What about classes, inheritance, etc.?
      li First solution: constructor functions

        pre.fragment: code.
          function Car(name) {
            this.name = name;
            this.drive = function() {
              console.log(this.name + " goes vroom!");
            };
          }

          var ferrari = new Car("Ferrari");
          ferrari.drive();  // -> "Ferrari goes vroom!"

          var ford = new Car("Ford");
          ford.drive();     // -> "Ford goes vroom!"

  section
    h2 Constructor Functions
    ul
      li What's happening here?
      li The <code>new</code> operator allocates a new object
      li In the context of the constructor, <code>this</code> refers 
        |to new object

        pre: code.
          function Car(name) {
            this.name = name;
            this.drive = function() {
              console.log(this.name + " goes vroom!");
            };
          }

          var ferrari = new Car("Ferrari");

      li.fragment <code>new</code> also sets the hidden <code>constructor</code> property

        pre: code.
          ferrari.constructor; // -> function Car() {...}

  section
    h2 Constructor Functions, Part II
    ul
      li Problem with this approach?

        pre: code.
          ferrari.drive // -> function () {
                        //      console.log(this.name + " goes vroom!");
                        //    }
          ford.drive    // -> function () {
                        //      console.log(this.name + " goes vroom!");
                        //    }

          ferrari.drive == ford.drive // -> false (duh!)

      li We're wasting resources by defining the same function <em>twice</em>
      li How can two objects share the same functionality?
      li Solution: use the <em>prototype</em>

  section
    h2 The Prototype
    ul
      li Objects have another hidden property called <code>prototype</code>
      li This is how to use it:

        pre: code.
          function Car(name) {
            this.name = name;
          }

          Car.prototype.drive = function() {
            console.log(this.name + " goes vroom!");
          };

          var ferrari = new Car("Ferrari");
          ferrari.drive();  // -> "Ferrari goes vroom!"

          var ford = new Car("Ford");
          ford.drive();     // -> "Ford goes vroom!"

          ferrari.drive == ford.drive // -> true

      .fragment &rArr; We now have a simple pattern to do OOP

  section
    h2 The Prototype, Part II
    ul
      li Let's go back to our
        a(href='#/2/4') previous question

        pre: code.
          function show(obj) {
            for (var key in obj) {
              console.log(key + "=" + obj[key]);
            }
          }

          show(ferrari);

      li Result:

        pre: code.
          name=Ferrari
          drive=function () {
            console.log(this.name + " goes vroom!");
          }

  section
    h2 The Prototype, Part III
    ul
      li <code>Car.prototype</code> could have its own prototype

        pre: code.
          function Vehicle(wheels) {
            this.wheels = wheels;
          }

          // redefine Car.prototype
          Car.prototype = new Vehicle(4);
          Car.prototype.drive = function() {...}

          var ferrari = new Car("Ferrari");

          show(ferrari);

      li Result?

        pre.fragment: code.
          name=Ferrari
          wheels=4
          drive=function () {
            console.log(this.name + " goes vroom!");
          }

  section
    h2 The Prototype, Part IV
    ul
      li What if we add something to the <code>Vehicle</code> prototype?

        pre: code.
          Vehicle.prototype.getAxes = function() {
            // assume 2 wheels per axis
            return this.wheels / 2;
          }

          show(ferrari);

      li.fragment Result?

        pre: code.
          name=Ferrari
          wheels=4
          drive=function () {...}
          getAxes=function () {...}

      li.fragment The new function automatically appears to be a member
        |of our <code>Car</code> instance
      li.fragment We didn't even have to call the constructor again

  section
    :markdown
      ## What have we learned?
      * `for in` iterates over *all* properties, 
        including those defined on the *prototype*
      * In fact, looking up a property of an object traverses the
        *entire* "prototype-chain" until either a match is 
        found or the end of the chain is reached <br/>
        (i.e. `prototype == undefined`)
      * This is the *essence* of JavaScript's object model

  section
    h2 What next?
