section
  section
    h1 Object Orientation

  section
    h2 Object Orientation
    ul
      li What we've learned so far:
        :markdown
          - Objects are hashmaps, mapping keys to values
          - Properties can be acessed using either `[]` or dot-notation
          - We can construct objects using literal notation (JSON)
          - Functions are values, just like primitive types

  section
    h2 Object Orientation, Part II
    ul
      li Functions are values &rArr; we can assign them to properties

        pre: code.
          var car = {
            name: "Ferrari",
            drive: function() {
              console.log(this.name + " goes vroom!");
            }
          }

          car.drive();   // -> "Ferrari goes vroom!"

      li A <em>method</em> is simply a property whose value is a <em>function</em>
      li When a function is called via an <em>object reference</em>,
        |<code>this</code> will point to the object it was invoked on
      li We can also do this explicitly via <code>call</code> or <code>apply</code>

        pre: code.
          var drive = car.drive;
          drive(); // -> 'undefined goes vroom!'
          drive.call(car, arguments);    // using an argument list
          drive.apply(car, [arguments]); // using an argument array

  section
    h2 Object Orientation, Part III
    ul
      li This approach seems fairly limited
      li All we can do is construct literal objects
      li Essentially, all our objects are <em>singletons</em>
      li What about classes, inheritance, etc.?
      li Solution: constructor functions

  section
    h2 Constructor functions
    ul
      li A constructor function is actually just a regular function
      li Only difference is the invocation with the <code>new</code> operator
      li By convention, we use a <em>capitalized</em> name

        pre: code.
          function Car(name) {
            this.name = name;
            this.drive = function() {
              console.log(this.name + " goes vroom!");
            };
            // NOTE: no return statement!
          }

          var ferrari = new Car("Ferrari");
          ferrari.drive();  // -> "Ferrari goes vroom!"

          var ford = new Car("Ford");
          ford.drive();     // -> "Ford goes vroom!"

      li The <code>new</code> operator allocates a new object
      li The constructor function is invoked on the new object

  section
    h2 Constructor Functions, Part II
    ul
      li Problem with this approach?

        pre: code.
          ferrari.drive // -> function () {
                        //      console.log(this.name + " goes vroom!");
                        //    }
          ford.drive    // -> function () {
                        //      console.log(this.name + " goes vroom!");
                        //    }

          ferrari.drive == ford.drive // -> false

      li We're wasting resources by defining the same function <em>twice</em>
      li How can two objects share the same functionality?

  section
    h2 Enter the Prototype
    ul
      li Functions have a hidden property called <code>prototype</code>
      li This is actually just another object
      li However, many objects can share the same prototype
      li Properties defined on the prototype will be shared between 
        |all objects with the same prototype

  section
    h2 The Prototype
    ul
      li Here's how to use it:

        pre(style="width: 110%"): code.
          function Car(name) {
            this.name = name;
          }

          // default prototype is an empty object
          Car.prototype; // -> {}

          // define method(s) on the prototype
          Car.prototype.drive = function() {
            console.log(this.name + " goes vroom!");
          };

      li.fragment Now we can do this:

        pre(style="width: 110%"): code.
          var ferrari = new Car("Ferrari");
          ferrari.drive();  // -> "Ferrari goes vroom!"

          var ford = new Car("Ford");
          ford.drive();     // -> "Ford goes vroom!"

          ferrari.drive == ford.drive // -> true

  section
    h2 The Prototype
    h3 What happens behind the scenes
    ul
      li In addition to allocating a new object and calling the constructor on it,
        |the <code>new</code> operator has another side effect
      li It sets the hidden property <code>__proto__</code> of the new object to
        |the <code>prototype</code> of its constructor function

        pre: code.javascript.
          ferrari.__proto__; // -> { drive: [Function] }
          ferrari.__proto__ == Car.prototype;  // -> true

  section
    h2 The Prototype Chain
    ul
      li All objects have a <code>__proto__</code> property
      li This creates what is know as the <em>prototype chain</em>

        pre: code.
          ferrari.__proto__; // -> { drive: [Function] }
          ferrari.__proto__.__proto__; // -> {}
          ferrari.__proto__.__proto__.__proto__; // -> null

      li Every time we look up a property, JavaScript traverses the
        |entire chain in order to find it
      li <code>null</code> signals the end of the chain
      li If the property is not found, the result is <code>undefined</code>
      li Only way to find out whether a property is inherited or not: <code>hasOwnProperty()</code>

  section
    h2 hasOwnProperty()
    ul
      li To find out whether a property is defined on a given object or inherited,
        |JavaScript provides the <code>hasOwnProperty()</code> method
      li This method is defined on <code>Object.prototype</code>
      li Some examples:

        pre(style="width:100%"): code.javascript.
          ferrari.hasOwnProperty('name');  // -> true
          ferrari.hasOwnProperty('drive'); // -> false (inherited from prototype)
          Car.prototype.hasOwnProperty('drive');             // -> true
          Object.prototype.hasOwnProperty('hasOwnProperty'); // -> true

      li.fragment Watch out: It is possible to <em>redefine</em> <code>hasOwnProperty</code>!

        pre: code.javascript.
          ferrari.hasOwnProperty = function() { return true; } // works!
          ferrari.hasOwnProperty('drive'); // -> true

        &rArr; DON'T DO THAT!

